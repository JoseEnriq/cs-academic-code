#include <iostream>
#include <vector>
#include <stack>
#include <cmath>
#include <random>
#include <boost/interprocess/shared_memory_object.hpp>
#include <boost/interprocess/mapped_region.hpp>

using namespace std;
using namespace boost::interprocess;

// Função para verificar se um número é primo
bool verificaPrimo(int n) 
{
    if (n <= 1) return false;
    if (n <= 3) return true;
    if (n % 2 == 0 || n % 3 == 0) return false;
    
    for (int i = 5; i * i <= n; i += 6)
    {
        if (n % i == 0 || n % (i + 2) == 0)
            return false;
    }
    
    return true;
}

// Função para preencher um vetor com números primos aleatórios
void preencherVetor(vector<int>& vetor)
{
    random_device rd;
    mt19937 gen(rd());
    uniform_int_distribution<int> dist(2, 10000); // Intervalo para os números primos

    int count = 0;
    while (count < 1000) 
    {
        int num = dist(gen); // Gera um número aleatório
        if (verificaPrimo(num)) // Verifica se é primo
        { 
            vetor.push_back(num); // Adiciona ao vetor
            count++;
        }
    }
}

// Definição de um nó de árvore binária
struct Node 
{
    int data;
    Node* left;
    Node* right;
};

// Função para criar um novo nó da árvore binária
Node* createNode(int value) 
{
    Node* newNode = new Node();
    newNode->data = value;
    newNode->left = newNode->right = nullptr;
    
    return newNode;
}

// Função para inserir valores da pilha na árvore binária balanceada
Node* inserirArvore(stack<int>& pilha, int start, int end) 
{
    if (start > end) // Caso base
        return nullptr;

    int mid = (start + end) / 2;
    int data = pilha.top(); // Obtém o valor do topo da pilha
    pilha.pop();

    Node* root = createNode(data);
    root->left = inserirArvore(pilha, start, mid - 1);
    root->right = inserirArvore(pilha, mid + 1, end);
    
    return root;
}

// Função para percorrer a árvore binária em ordem
void ordemTraversal(Node* root) 
{
    if (root == nullptr) return;
    ordemTraversal(root->left);
    cout << root->data << " ";
    ordemTraversal(root->right);
}

int main()
{
    // Criando memória compartilhada
    shared_memory_object shm(open_or_create, "SharedMemory", read_write);
    shm.truncate(sizeof(int) * 1000);

    // Mapeando memória compartilhada
    mapped_region region(shm, read_write);
    void* addr = region.get_address();
    int* shared_data = static_cast<int*>(addr);

    // Preenchendo vetor com números primos
    vector<int> vetor;
    preencherVetor(vetor);

    // Copiando números primos para a memória compartilhada
    for (int i = 0; i < 1000; ++i)
    {
        shared_data[i] = vetor[i];
    }

    cout << "Números primos gerados e armazenados na memória compartilhada." << endl;

    // Copiando números primos da memória compartilhada para a pilha
    stack<int> pilha;
    for (int i = 999; i >= 0; --i) 
    {
        pilha.push(shared_data[i]);
    }

    Node* root = inserirArvore(pilha, 0, 999); // Inserindo na árvore balanceada

    cout << "Valores da árvore binária balanceada:" << endl;
    ordemTraversal(root);
    cout << endl;

    // Removendo memória compartilhada
    shared_memory_object::remove("SharedMemory");

    return 0;
}